// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package godid

import (
	"sync"
	"time"
)

var (
	lockentryStoreMockGetRange                sync.RWMutex
	lockentryStoreMockGetRangeWithAggregation sync.RWMutex
	lockentryStoreMockPut                     sync.RWMutex
)

// entryStoreMock is a mock implementation of entryStore.
//
//     func TestSomethingThatUsesentryStore(t *testing.T) {
//
//         // make and configure a mocked entryStore
//         mockedentryStore := &entryStoreMock{
//             GetRangeFunc: func(start time.Time, end time.Time) ([]entry, error) {
// 	               panic("TODO: mock out the GetRange method")
//             },
//             GetRangeWithAggregationFunc: func(start time.Time, end time.Time, agg aggregationFunction) (interface{}, error) {
// 	               panic("TODO: mock out the GetRangeWithAggregation method")
//             },
//             PutFunc: func(in1 entry) error {
// 	               panic("TODO: mock out the Put method")
//             },
//         }
//
//         // TODO: use mockedentryStore in code that requires entryStore
//         //       and then make assertions.
//
//     }
type entryStoreMock struct {
	// GetRangeFunc mocks the GetRange method.
	GetRangeFunc func(start time.Time, end time.Time) ([]entry, error)

	// GetRangeWithAggregationFunc mocks the GetRangeWithAggregation method.
	GetRangeWithAggregationFunc func(start time.Time, end time.Time, agg aggregationFunction) (interface{}, error)

	// PutFunc mocks the Put method.
	PutFunc func(in1 entry) error

	// calls tracks calls to the methods.
	calls struct {
		// GetRange holds details about calls to the GetRange method.
		GetRange []struct {
			// Start is the start argument value.
			Start time.Time
			// End is the end argument value.
			End time.Time
		}
		// GetRangeWithAggregation holds details about calls to the GetRangeWithAggregation method.
		GetRangeWithAggregation []struct {
			// Start is the start argument value.
			Start time.Time
			// End is the end argument value.
			End time.Time
			// Agg is the agg argument value.
			Agg aggregationFunction
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// In1 is the in1 argument value.
			In1 entry
		}
	}
}

// GetRange calls GetRangeFunc.
func (mock *entryStoreMock) GetRange(start time.Time, end time.Time) ([]entry, error) {
	if mock.GetRangeFunc == nil {
		panic("entryStoreMock.GetRangeFunc: method is nil but entryStore.GetRange was just called")
	}
	callInfo := struct {
		Start time.Time
		End   time.Time
	}{
		Start: start,
		End:   end,
	}
	lockentryStoreMockGetRange.Lock()
	mock.calls.GetRange = append(mock.calls.GetRange, callInfo)
	lockentryStoreMockGetRange.Unlock()
	return mock.GetRangeFunc(start, end)
}

// GetRangeCalls gets all the calls that were made to GetRange.
// Check the length with:
//     len(mockedentryStore.GetRangeCalls())
func (mock *entryStoreMock) GetRangeCalls() []struct {
	Start time.Time
	End   time.Time
} {
	var calls []struct {
		Start time.Time
		End   time.Time
	}
	lockentryStoreMockGetRange.RLock()
	calls = mock.calls.GetRange
	lockentryStoreMockGetRange.RUnlock()
	return calls
}

// GetRangeWithAggregation calls GetRangeWithAggregationFunc.
func (mock *entryStoreMock) GetRangeWithAggregation(start time.Time, end time.Time, agg aggregationFunction) (interface{}, error) {
	if mock.GetRangeWithAggregationFunc == nil {
		panic("entryStoreMock.GetRangeWithAggregationFunc: method is nil but entryStore.GetRangeWithAggregation was just called")
	}
	callInfo := struct {
		Start time.Time
		End   time.Time
		Agg   aggregationFunction
	}{
		Start: start,
		End:   end,
		Agg:   agg,
	}
	lockentryStoreMockGetRangeWithAggregation.Lock()
	mock.calls.GetRangeWithAggregation = append(mock.calls.GetRangeWithAggregation, callInfo)
	lockentryStoreMockGetRangeWithAggregation.Unlock()
	return mock.GetRangeWithAggregationFunc(start, end, agg)
}

// GetRangeWithAggregationCalls gets all the calls that were made to GetRangeWithAggregation.
// Check the length with:
//     len(mockedentryStore.GetRangeWithAggregationCalls())
func (mock *entryStoreMock) GetRangeWithAggregationCalls() []struct {
	Start time.Time
	End   time.Time
	Agg   aggregationFunction
} {
	var calls []struct {
		Start time.Time
		End   time.Time
		Agg   aggregationFunction
	}
	lockentryStoreMockGetRangeWithAggregation.RLock()
	calls = mock.calls.GetRangeWithAggregation
	lockentryStoreMockGetRangeWithAggregation.RUnlock()
	return calls
}

// Put calls PutFunc.
func (mock *entryStoreMock) Put(in1 entry) error {
	if mock.PutFunc == nil {
		panic("entryStoreMock.PutFunc: method is nil but entryStore.Put was just called")
	}
	callInfo := struct {
		In1 entry
	}{
		In1: in1,
	}
	lockentryStoreMockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	lockentryStoreMockPut.Unlock()
	return mock.PutFunc(in1)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//     len(mockedentryStore.PutCalls())
func (mock *entryStoreMock) PutCalls() []struct {
	In1 entry
} {
	var calls []struct {
		In1 entry
	}
	lockentryStoreMockPut.RLock()
	calls = mock.calls.Put
	lockentryStoreMockPut.RUnlock()
	return calls
}
